/* tslint:disable */
/* eslint-disable */
//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v12.2.0.0 (NJsonSchema v9.13.35.0 (Newtonsoft.Json v11.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------
// ReSharper disable InconsistentNaming

import { mergeMap as _observableMergeMap, catchError as _observableCatch } from 'rxjs/operators';
import { Observable, throwError as _observableThrow, of as _observableOf } from 'rxjs';
import { Injectable, Inject, Optional, InjectionToken } from '@angular/core';
import { HttpClient, HttpHeaders, HttpResponse, HttpResponseBase } from '@angular/common/http';

import * as moment from 'moment';

export const ARTOUR_API_BASE_URL = new InjectionToken<string>('ARTOUR_API_BASE_URL');

@Injectable()
export class ArtourApiService {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(ARTOUR_API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getAllCities(): Observable<CityViewModel[]> {
        let url_ = this.baseUrl + "/api/locations/cities";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllCities(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllCities(<any>response_);
                } catch (e) {
                    return <Observable<CityViewModel[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<CityViewModel[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllCities(response: HttpResponseBase): Observable<CityViewModel[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(CityViewModel.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CityViewModel[]>(<any>null);
    }

    /**
     * @return Success
     */
    getAllCountries(): Observable<CountryViewModel[]> {
        let url_ = this.baseUrl + "/api/locations/countries";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllCountries(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllCountries(<any>response_);
                } catch (e) {
                    return <Observable<CountryViewModel[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<CountryViewModel[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllCountries(response: HttpResponseBase): Observable<CountryViewModel[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(CountryViewModel.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CountryViewModel[]>(<any>null);
    }

    /**
     * @return Success
     */
    getAllRegions(): Observable<RegionViewModel[]> {
        let url_ = this.baseUrl + "/api/locations/regions";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllRegions(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllRegions(<any>response_);
                } catch (e) {
                    return <Observable<RegionViewModel[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<RegionViewModel[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllRegions(response: HttpResponseBase): Observable<RegionViewModel[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(RegionViewModel.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RegionViewModel[]>(<any>null);
    }

    /**
     * @return Success
     */
    checkConnection(): Observable<void> {
        let url_ = this.baseUrl + "/api/service/connection";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCheckConnection(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCheckConnection(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCheckConnection(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @return Success
     */
    restart(): Observable<void> {
        let url_ = this.baseUrl + "/api/service/restart";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRestart(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRestart(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processRestart(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @return Success
     */
    getImageById(id: number): Observable<SightImageViewModel> {
        let url_ = this.baseUrl + "/api/sight-images/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetImageById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetImageById(<any>response_);
                } catch (e) {
                    return <Observable<SightImageViewModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<SightImageViewModel>><any>_observableThrow(response_);
        }));
    }

    protected processGetImageById(response: HttpResponseBase): Observable<SightImageViewModel> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? SightImageViewModel.fromJS(resultData200) : new SightImageViewModel();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SightImageViewModel>(<any>null);
    }

    /**
     * @param fileToSave Upload file.
     * @return Success
     */
    updateImage(id: number, fileToSave: FileParameter): Observable<void> {
        let url_ = this.baseUrl + "/api/sight-images/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (fileToSave === null || fileToSave === undefined)
            throw new Error("The parameter 'fileToSave' cannot be null.");
        else
            content_.append("fileToSave", fileToSave.data, fileToSave.fileName ? fileToSave.fileName : "fileToSave");

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateImage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateImage(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateImage(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @return Success
     */
    deleteImage(id: number): Observable<void> {
        let url_ = this.baseUrl + "/api/sight-images/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteImage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteImage(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteImage(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @return Success
     */
    getImageDataById(id: number): Observable<void> {
        let url_ = this.baseUrl + "/api/sight-images/{id}/data";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetImageDataById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetImageDataById(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processGetImageDataById(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param description (optional) 
     * @param fileToSave Upload file.
     * @return Success
     */
    createSightImage(description: string | null | undefined, sightId: number, fileToSave: FileParameter): Observable<SightImageViewModel> {
        let url_ = this.baseUrl + "/api/sight-images/{sightId}";
        if (sightId === undefined || sightId === null)
            throw new Error("The parameter 'sightId' must be defined.");
        url_ = url_.replace("{sightId}", encodeURIComponent("" + sightId)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (description !== null && description !== undefined)
            content_.append("description", description.toString());
        if (fileToSave === null || fileToSave === undefined)
            throw new Error("The parameter 'fileToSave' cannot be null.");
        else
            content_.append("fileToSave", fileToSave.data, fileToSave.fileName ? fileToSave.fileName : "fileToSave");

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateSightImage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateSightImage(<any>response_);
                } catch (e) {
                    return <Observable<SightImageViewModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<SightImageViewModel>><any>_observableThrow(response_);
        }));
    }

    protected processCreateSightImage(response: HttpResponseBase): Observable<SightImageViewModel> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? SightImageViewModel.fromJS(resultData200) : new SightImageViewModel();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SightImageViewModel>(<any>null);
    }

    /**
     * @param model (optional) 
     * @return Success
     */
    updateInfo(id: number, model: SightImageViewModel | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/sight-images/{id}/info";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateInfo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateInfo(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateInfo(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param previousOrder (optional) 
     * @param currentOrder (optional) 
     * @param sightId (optional) 
     * @return Success
     */
    changeOrder(previousOrder: number | null | undefined, currentOrder: number | null | undefined, sightId: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/sight-images/change-order?";
        if (previousOrder !== undefined)
            url_ += "previousOrder=" + encodeURIComponent("" + previousOrder) + "&"; 
        if (currentOrder !== undefined)
            url_ += "currentOrder=" + encodeURIComponent("" + currentOrder) + "&"; 
        if (sightId !== undefined)
            url_ += "sightId=" + encodeURIComponent("" + sightId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processChangeOrder(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processChangeOrder(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processChangeOrder(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @return Success
     */
    getSightById(sightId: number): Observable<SightViewModel> {
        let url_ = this.baseUrl + "/api/sights/{sightId}";
        if (sightId === undefined || sightId === null)
            throw new Error("The parameter 'sightId' must be defined.");
        url_ = url_.replace("{sightId}", encodeURIComponent("" + sightId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSightById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSightById(<any>response_);
                } catch (e) {
                    return <Observable<SightViewModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<SightViewModel>><any>_observableThrow(response_);
        }));
    }

    protected processGetSightById(response: HttpResponseBase): Observable<SightViewModel> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? SightViewModel.fromJS(resultData200) : new SightViewModel();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SightViewModel>(<any>null);
    }

    /**
     * @param sight (optional) 
     * @return Success
     */
    updateSight(sightId: number, sight: SightViewModel | null | undefined): Observable<SightViewModel> {
        let url_ = this.baseUrl + "/api/sights/{sightId}";
        if (sightId === undefined || sightId === null)
            throw new Error("The parameter 'sightId' must be defined.");
        url_ = url_.replace("{sightId}", encodeURIComponent("" + sightId)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(sight);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateSight(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateSight(<any>response_);
                } catch (e) {
                    return <Observable<SightViewModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<SightViewModel>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateSight(response: HttpResponseBase): Observable<SightViewModel> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? SightViewModel.fromJS(resultData200) : new SightViewModel();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SightViewModel>(<any>null);
    }

    /**
     * @return Success
     */
    deleteSight(sightId: number): Observable<void> {
        let url_ = this.baseUrl + "/api/sights/{sightId}";
        if (sightId === undefined || sightId === null)
            throw new Error("The parameter 'sightId' must be defined.");
        url_ = url_.replace("{sightId}", encodeURIComponent("" + sightId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteSight(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteSight(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteSight(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @return Success
     */
    getSightsByTourId(tourId: number): Observable<SightViewModel[]> {
        let url_ = this.baseUrl + "/api/sights/tour/{tourId}";
        if (tourId === undefined || tourId === null)
            throw new Error("The parameter 'tourId' must be defined.");
        url_ = url_.replace("{tourId}", encodeURIComponent("" + tourId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSightsByTourId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSightsByTourId(<any>response_);
                } catch (e) {
                    return <Observable<SightViewModel[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<SightViewModel[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetSightsByTourId(response: HttpResponseBase): Observable<SightViewModel[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(SightViewModel.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SightViewModel[]>(<any>null);
    }

    /**
     * @param sight (optional) 
     * @return Success
     */
    createSight(sight: SightViewModel | null | undefined): Observable<SightViewModel> {
        let url_ = this.baseUrl + "/api/sights";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(sight);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateSight(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateSight(<any>response_);
                } catch (e) {
                    return <Observable<SightViewModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<SightViewModel>><any>_observableThrow(response_);
        }));
    }

    protected processCreateSight(response: HttpResponseBase): Observable<SightViewModel> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? SightViewModel.fromJS(resultData200) : new SightViewModel();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SightViewModel>(<any>null);
    }

    /**
     * @param sightSeen (optional) 
     * @return Success
     */
    createSightSeen(sightSeen: SightSeenViewModel | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/sight-seens";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(sightSeen);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateSightSeen(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateSightSeen(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateSightSeen(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @return Success
     */
    getAllTours(): Observable<TourViewModel[]> {
        let url_ = this.baseUrl + "/api/tours";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllTours(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllTours(<any>response_);
                } catch (e) {
                    return <Observable<TourViewModel[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<TourViewModel[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllTours(response: HttpResponseBase): Observable<TourViewModel[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(TourViewModel.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TourViewModel[]>(<any>null);
    }

    /**
     * @param tour (optional) 
     * @return Success
     */
    createTour(tour: TourViewModel | null | undefined): Observable<TourViewModel> {
        let url_ = this.baseUrl + "/api/tours";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(tour);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateTour(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateTour(<any>response_);
                } catch (e) {
                    return <Observable<TourViewModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<TourViewModel>><any>_observableThrow(response_);
        }));
    }

    protected processCreateTour(response: HttpResponseBase): Observable<TourViewModel> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? TourViewModel.fromJS(resultData200) : new TourViewModel();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TourViewModel>(<any>null);
    }

    /**
     * @return Success
     */
    getTour(tourId: number): Observable<TourViewModel> {
        let url_ = this.baseUrl + "/api/tours/{tourId}";
        if (tourId === undefined || tourId === null)
            throw new Error("The parameter 'tourId' must be defined.");
        url_ = url_.replace("{tourId}", encodeURIComponent("" + tourId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTour(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTour(<any>response_);
                } catch (e) {
                    return <Observable<TourViewModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<TourViewModel>><any>_observableThrow(response_);
        }));
    }

    protected processGetTour(response: HttpResponseBase): Observable<TourViewModel> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? TourViewModel.fromJS(resultData200) : new TourViewModel();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TourViewModel>(<any>null);
    }

    /**
     * @param tour (optional) 
     * @return Success
     */
    updateTour(tourId: number, tour: TourViewModel | null | undefined): Observable<TourViewModel> {
        let url_ = this.baseUrl + "/api/tours/{tourId}";
        if (tourId === undefined || tourId === null)
            throw new Error("The parameter 'tourId' must be defined.");
        url_ = url_.replace("{tourId}", encodeURIComponent("" + tourId)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(tour);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateTour(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateTour(<any>response_);
                } catch (e) {
                    return <Observable<TourViewModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<TourViewModel>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateTour(response: HttpResponseBase): Observable<TourViewModel> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? TourViewModel.fromJS(resultData200) : new TourViewModel();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TourViewModel>(<any>null);
    }

    /**
     * @return Success
     */
    deleteTour(tourId: number): Observable<void> {
        let url_ = this.baseUrl + "/api/tours/{tourId}";
        if (tourId === undefined || tourId === null)
            throw new Error("The parameter 'tourId' must be defined.");
        url_ = url_.replace("{tourId}", encodeURIComponent("" + tourId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteTour(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteTour(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteTour(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @return Success
     */
    getTourStatistics(tourId: number): Observable<TourStatisticsViewModel> {
        let url_ = this.baseUrl + "/api/tours/{tourId}/statistics";
        if (tourId === undefined || tourId === null)
            throw new Error("The parameter 'tourId' must be defined.");
        url_ = url_.replace("{tourId}", encodeURIComponent("" + tourId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTourStatistics(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTourStatistics(<any>response_);
                } catch (e) {
                    return <Observable<TourStatisticsViewModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<TourStatisticsViewModel>><any>_observableThrow(response_);
        }));
    }

    protected processGetTourStatistics(response: HttpResponseBase): Observable<TourStatisticsViewModel> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? TourStatisticsViewModel.fromJS(resultData200) : new TourStatisticsViewModel();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TourStatisticsViewModel>(<any>null);
    }

    /**
     * @return Success
     */
    getUsersTours(userId: number): Observable<TourViewModel[]> {
        let url_ = this.baseUrl + "/api/tours/user/{userId}";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUsersTours(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUsersTours(<any>response_);
                } catch (e) {
                    return <Observable<TourViewModel[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<TourViewModel[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetUsersTours(response: HttpResponseBase): Observable<TourViewModel[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(TourViewModel.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TourViewModel[]>(<any>null);
    }

    /**
     * @return Success
     */
    getUsers(): Observable<UserViewModel[]> {
        let url_ = this.baseUrl + "/api/users";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUsers(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUsers(<any>response_);
                } catch (e) {
                    return <Observable<UserViewModel[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<UserViewModel[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetUsers(response: HttpResponseBase): Observable<UserViewModel[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(UserViewModel.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserViewModel[]>(<any>null);
    }

    /**
     * @return Success
     */
    sendUserCode(userId: number): Observable<number> {
        let url_ = this.baseUrl + "/api/users/{userId}/send-code";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSendUserCode(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSendUserCode(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processSendUserCode(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }

    /**
     * @return Success
     */
    getUser(userId: number): Observable<UserViewModel> {
        let url_ = this.baseUrl + "/api/users/{userId}";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUser(<any>response_);
                } catch (e) {
                    return <Observable<UserViewModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<UserViewModel>><any>_observableThrow(response_);
        }));
    }

    protected processGetUser(response: HttpResponseBase): Observable<UserViewModel> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? UserViewModel.fromJS(resultData200) : new UserViewModel();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserViewModel>(<any>null);
    }

    /**
     * @param userViewModel (optional) 
     * @return Success
     */
    updateUser(userId: number, userViewModel: UserViewModel | null | undefined): Observable<UserViewModel> {
        let url_ = this.baseUrl + "/api/users/{userId}";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(userViewModel);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateUser(<any>response_);
                } catch (e) {
                    return <Observable<UserViewModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<UserViewModel>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateUser(response: HttpResponseBase): Observable<UserViewModel> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? UserViewModel.fromJS(resultData200) : new UserViewModel();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserViewModel>(<any>null);
    }

    /**
     * @return Success
     */
    getUserStatistics(userId: number): Observable<UserStatisticsViewModel> {
        let url_ = this.baseUrl + "/api/users/{userId}/statistics";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUserStatistics(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUserStatistics(<any>response_);
                } catch (e) {
                    return <Observable<UserStatisticsViewModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<UserStatisticsViewModel>><any>_observableThrow(response_);
        }));
    }

    protected processGetUserStatistics(response: HttpResponseBase): Observable<UserStatisticsViewModel> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? UserStatisticsViewModel.fromJS(resultData200) : new UserStatisticsViewModel();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserStatisticsViewModel>(<any>null);
    }

    /**
     * @param login (optional) 
     * @return Success
     */
    loginUser(login: LoginViewModel | null | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/users/login";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(login);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processLoginUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processLoginUser(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processLoginUser(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }

    /**
     * @param newUser (optional) 
     * @return Success
     */
    registerUser(newUser: RegisterViewModel | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/users/register";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(newUser);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRegisterUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRegisterUser(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processRegisterUser(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param email (optional) 
     * @return Success
     */
    sendConfirmationEmail(email: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/users/send-confirmation-email";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(email);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSendConfirmationEmail(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSendConfirmationEmail(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processSendConfirmationEmail(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param model (optional) 
     * @return Success
     */
    resetAndChangePassword(model: ResetPasswordViewModel | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/users/reset-and-change-password";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processResetAndChangePassword(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processResetAndChangePassword(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processResetAndChangePassword(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param passwordViewModel (optional) 
     * @return Success
     */
    changePassword(userId: number, passwordViewModel: ChangePasswordViewModel | null | undefined): Observable<UserViewModel> {
        let url_ = this.baseUrl + "/api/users/{userId}/change-password";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(passwordViewModel);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processChangePassword(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processChangePassword(<any>response_);
                } catch (e) {
                    return <Observable<UserViewModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<UserViewModel>><any>_observableThrow(response_);
        }));
    }

    protected processChangePassword(response: HttpResponseBase): Observable<UserViewModel> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? UserViewModel.fromJS(resultData200) : new UserViewModel();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserViewModel>(<any>null);
    }

    /**
     * @return Success
     */
    getVisit(visitId: string): Observable<VisitViewModel> {
        let url_ = this.baseUrl + "/api/visits/{visitId}";
        if (visitId === undefined || visitId === null)
            throw new Error("The parameter 'visitId' must be defined.");
        url_ = url_.replace("{visitId}", encodeURIComponent("" + visitId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetVisit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetVisit(<any>response_);
                } catch (e) {
                    return <Observable<VisitViewModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<VisitViewModel>><any>_observableThrow(response_);
        }));
    }

    protected processGetVisit(response: HttpResponseBase): Observable<VisitViewModel> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? VisitViewModel.fromJS(resultData200) : new VisitViewModel();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<VisitViewModel>(<any>null);
    }

    /**
     * @param visit (optional) 
     * @return Success
     */
    startVisit(visit: VisitViewModel | null | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/visits/start";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(visit);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processStartVisit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processStartVisit(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processStartVisit(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }

    /**
     * @return Success
     */
    finishVisit(visitId: string): Observable<void> {
        let url_ = this.baseUrl + "/api/visits/{visitId}/finish";
        if (visitId === undefined || visitId === null)
            throw new Error("The parameter 'visitId' must be defined.");
        url_ = url_.replace("{visitId}", encodeURIComponent("" + visitId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFinishVisit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFinishVisit(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processFinishVisit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

export class CityViewModel implements ICityViewModel {
    cityId?: number | undefined;
    name?: string | undefined;
    countryId?: number | undefined;
    country?: CountryViewModel | undefined;
    tours?: TourViewModel[] | undefined;

    constructor(data?: ICityViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.cityId = data["cityId"];
            this.name = data["name"];
            this.countryId = data["countryId"];
            this.country = data["country"] ? CountryViewModel.fromJS(data["country"]) : <any>undefined;
            if (data["tours"] && data["tours"].constructor === Array) {
                this.tours = [] as any;
                for (let item of data["tours"])
                    this.tours!.push(TourViewModel.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CityViewModel {
        data = typeof data === 'object' ? data : {};
        let result = new CityViewModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["cityId"] = this.cityId;
        data["name"] = this.name;
        data["countryId"] = this.countryId;
        data["country"] = this.country ? this.country.toJSON() : <any>undefined;
        if (this.tours && this.tours.constructor === Array) {
            data["tours"] = [];
            for (let item of this.tours)
                data["tours"].push(item.toJSON());
        }
        return data; 
    }
}

export interface ICityViewModel {
    cityId?: number | undefined;
    name?: string | undefined;
    countryId?: number | undefined;
    country?: CountryViewModel | undefined;
    tours?: TourViewModel[] | undefined;
}

export class CountryViewModel implements ICountryViewModel {
    countryId?: number | undefined;
    name?: string | undefined;
    code?: string | undefined;
    regionId?: number | undefined;
    region?: RegionViewModel | undefined;
    cities?: CityViewModel[] | undefined;

    constructor(data?: ICountryViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.countryId = data["countryId"];
            this.name = data["name"];
            this.code = data["code"];
            this.regionId = data["regionId"];
            this.region = data["region"] ? RegionViewModel.fromJS(data["region"]) : <any>undefined;
            if (data["cities"] && data["cities"].constructor === Array) {
                this.cities = [] as any;
                for (let item of data["cities"])
                    this.cities!.push(CityViewModel.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CountryViewModel {
        data = typeof data === 'object' ? data : {};
        let result = new CountryViewModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["countryId"] = this.countryId;
        data["name"] = this.name;
        data["code"] = this.code;
        data["regionId"] = this.regionId;
        data["region"] = this.region ? this.region.toJSON() : <any>undefined;
        if (this.cities && this.cities.constructor === Array) {
            data["cities"] = [];
            for (let item of this.cities)
                data["cities"].push(item.toJSON());
        }
        return data; 
    }
}

export interface ICountryViewModel {
    countryId?: number | undefined;
    name?: string | undefined;
    code?: string | undefined;
    regionId?: number | undefined;
    region?: RegionViewModel | undefined;
    cities?: CityViewModel[] | undefined;
}

export class TourViewModel implements ITourViewModel {
    tourId?: number | undefined;
    ownerId?: number | undefined;
    title?: string | undefined;
    description?: string | undefined;
    cityId?: number | undefined;
    city?: CityViewModel | undefined;
    comments?: CommentViewModel[] | undefined;
    sights?: SightViewModel[] | undefined;
    visits?: VisitViewModel[] | undefined;

    constructor(data?: ITourViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tourId = data["tourId"];
            this.ownerId = data["ownerId"];
            this.title = data["title"];
            this.description = data["description"];
            this.cityId = data["cityId"];
            this.city = data["city"] ? CityViewModel.fromJS(data["city"]) : <any>undefined;
            if (data["comments"] && data["comments"].constructor === Array) {
                this.comments = [] as any;
                for (let item of data["comments"])
                    this.comments!.push(CommentViewModel.fromJS(item));
            }
            if (data["sights"] && data["sights"].constructor === Array) {
                this.sights = [] as any;
                for (let item of data["sights"])
                    this.sights!.push(SightViewModel.fromJS(item));
            }
            if (data["visits"] && data["visits"].constructor === Array) {
                this.visits = [] as any;
                for (let item of data["visits"])
                    this.visits!.push(VisitViewModel.fromJS(item));
            }
        }
    }

    static fromJS(data: any): TourViewModel {
        data = typeof data === 'object' ? data : {};
        let result = new TourViewModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tourId"] = this.tourId;
        data["ownerId"] = this.ownerId;
        data["title"] = this.title;
        data["description"] = this.description;
        data["cityId"] = this.cityId;
        data["city"] = this.city ? this.city.toJSON() : <any>undefined;
        if (this.comments && this.comments.constructor === Array) {
            data["comments"] = [];
            for (let item of this.comments)
                data["comments"].push(item.toJSON());
        }
        if (this.sights && this.sights.constructor === Array) {
            data["sights"] = [];
            for (let item of this.sights)
                data["sights"].push(item.toJSON());
        }
        if (this.visits && this.visits.constructor === Array) {
            data["visits"] = [];
            for (let item of this.visits)
                data["visits"].push(item.toJSON());
        }
        return data; 
    }
}

export interface ITourViewModel {
    tourId?: number | undefined;
    ownerId?: number | undefined;
    title?: string | undefined;
    description?: string | undefined;
    cityId?: number | undefined;
    city?: CityViewModel | undefined;
    comments?: CommentViewModel[] | undefined;
    sights?: SightViewModel[] | undefined;
    visits?: VisitViewModel[] | undefined;
}

export class RegionViewModel implements IRegionViewModel {
    regionId?: number | undefined;
    name?: string | undefined;
    countries?: CountryViewModel[] | undefined;

    constructor(data?: IRegionViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.regionId = data["regionId"];
            this.name = data["name"];
            if (data["countries"] && data["countries"].constructor === Array) {
                this.countries = [] as any;
                for (let item of data["countries"])
                    this.countries!.push(CountryViewModel.fromJS(item));
            }
        }
    }

    static fromJS(data: any): RegionViewModel {
        data = typeof data === 'object' ? data : {};
        let result = new RegionViewModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["regionId"] = this.regionId;
        data["name"] = this.name;
        if (this.countries && this.countries.constructor === Array) {
            data["countries"] = [];
            for (let item of this.countries)
                data["countries"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IRegionViewModel {
    regionId?: number | undefined;
    name?: string | undefined;
    countries?: CountryViewModel[] | undefined;
}

export class CommentViewModel implements ICommentViewModel {
    commentId?: number | undefined;
    userId?: number | undefined;
    tourId?: number | undefined;
    mark?: number | undefined;
    text?: string | undefined;

    constructor(data?: ICommentViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.commentId = data["commentId"];
            this.userId = data["userId"];
            this.tourId = data["tourId"];
            this.mark = data["mark"];
            this.text = data["text"];
        }
    }

    static fromJS(data: any): CommentViewModel {
        data = typeof data === 'object' ? data : {};
        let result = new CommentViewModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["commentId"] = this.commentId;
        data["userId"] = this.userId;
        data["tourId"] = this.tourId;
        data["mark"] = this.mark;
        data["text"] = this.text;
        return data; 
    }
}

export interface ICommentViewModel {
    commentId?: number | undefined;
    userId?: number | undefined;
    tourId?: number | undefined;
    mark?: number | undefined;
    text?: string | undefined;
}

export class SightViewModel implements ISightViewModel {
    sightId?: number | undefined;
    tourId?: number | undefined;
    title?: string | undefined;
    description?: string | undefined;
    images?: SightImageViewModel[] | undefined;
    sightSeens?: SightSeenViewModel[] | undefined;

    constructor(data?: ISightViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.sightId = data["sightId"];
            this.tourId = data["tourId"];
            this.title = data["title"];
            this.description = data["description"];
            if (data["images"] && data["images"].constructor === Array) {
                this.images = [] as any;
                for (let item of data["images"])
                    this.images!.push(SightImageViewModel.fromJS(item));
            }
            if (data["sightSeens"] && data["sightSeens"].constructor === Array) {
                this.sightSeens = [] as any;
                for (let item of data["sightSeens"])
                    this.sightSeens!.push(SightSeenViewModel.fromJS(item));
            }
        }
    }

    static fromJS(data: any): SightViewModel {
        data = typeof data === 'object' ? data : {};
        let result = new SightViewModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["sightId"] = this.sightId;
        data["tourId"] = this.tourId;
        data["title"] = this.title;
        data["description"] = this.description;
        if (this.images && this.images.constructor === Array) {
            data["images"] = [];
            for (let item of this.images)
                data["images"].push(item.toJSON());
        }
        if (this.sightSeens && this.sightSeens.constructor === Array) {
            data["sightSeens"] = [];
            for (let item of this.sightSeens)
                data["sightSeens"].push(item.toJSON());
        }
        return data; 
    }
}

export interface ISightViewModel {
    sightId?: number | undefined;
    tourId?: number | undefined;
    title?: string | undefined;
    description?: string | undefined;
    images?: SightImageViewModel[] | undefined;
    sightSeens?: SightSeenViewModel[] | undefined;
}

export class VisitViewModel implements IVisitViewModel {
    visitId?: string | undefined;
    userId?: number | undefined;
    tourId?: number | undefined;
    startDate?: moment.Moment | undefined;
    endDate?: moment.Moment | undefined;
    user?: UserViewModel | undefined;
    tour?: TourViewModel | undefined;
    sightSeens?: SightSeenViewModel[] | undefined;

    constructor(data?: IVisitViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.visitId = data["visitId"];
            this.userId = data["userId"];
            this.tourId = data["tourId"];
            this.startDate = data["startDate"] ? moment(data["startDate"].toString()) : <any>undefined;
            this.endDate = data["endDate"] ? moment(data["endDate"].toString()) : <any>undefined;
            this.user = data["user"] ? UserViewModel.fromJS(data["user"]) : <any>undefined;
            this.tour = data["tour"] ? TourViewModel.fromJS(data["tour"]) : <any>undefined;
            if (data["sightSeens"] && data["sightSeens"].constructor === Array) {
                this.sightSeens = [] as any;
                for (let item of data["sightSeens"])
                    this.sightSeens!.push(SightSeenViewModel.fromJS(item));
            }
        }
    }

    static fromJS(data: any): VisitViewModel {
        data = typeof data === 'object' ? data : {};
        let result = new VisitViewModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["visitId"] = this.visitId;
        data["userId"] = this.userId;
        data["tourId"] = this.tourId;
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        data["tour"] = this.tour ? this.tour.toJSON() : <any>undefined;
        if (this.sightSeens && this.sightSeens.constructor === Array) {
            data["sightSeens"] = [];
            for (let item of this.sightSeens)
                data["sightSeens"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IVisitViewModel {
    visitId?: string | undefined;
    userId?: number | undefined;
    tourId?: number | undefined;
    startDate?: moment.Moment | undefined;
    endDate?: moment.Moment | undefined;
    user?: UserViewModel | undefined;
    tour?: TourViewModel | undefined;
    sightSeens?: SightSeenViewModel[] | undefined;
}

export class SightImageViewModel implements ISightImageViewModel {
    sightImageId?: number | undefined;
    description?: string | undefined;
    uploadedOn?: moment.Moment | undefined;
    fileSize?: number | undefined;
    fullFilename?: string | undefined;
    order?: number | undefined;
    sightId?: number | undefined;

    constructor(data?: ISightImageViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.sightImageId = data["sightImageId"];
            this.description = data["description"];
            this.uploadedOn = data["uploadedOn"] ? moment(data["uploadedOn"].toString()) : <any>undefined;
            this.fileSize = data["fileSize"];
            this.fullFilename = data["fullFilename"];
            this.order = data["order"];
            this.sightId = data["sightId"];
        }
    }

    static fromJS(data: any): SightImageViewModel {
        data = typeof data === 'object' ? data : {};
        let result = new SightImageViewModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["sightImageId"] = this.sightImageId;
        data["description"] = this.description;
        data["uploadedOn"] = this.uploadedOn ? this.uploadedOn.toISOString() : <any>undefined;
        data["fileSize"] = this.fileSize;
        data["fullFilename"] = this.fullFilename;
        data["order"] = this.order;
        data["sightId"] = this.sightId;
        return data; 
    }
}

export interface ISightImageViewModel {
    sightImageId?: number | undefined;
    description?: string | undefined;
    uploadedOn?: moment.Moment | undefined;
    fileSize?: number | undefined;
    fullFilename?: string | undefined;
    order?: number | undefined;
    sightId?: number | undefined;
}

export class SightSeenViewModel implements ISightSeenViewModel {
    visitId?: string | undefined;
    dateSeen?: moment.Moment | undefined;
    sightSeenId?: number | undefined;
    sightId?: number | undefined;

    constructor(data?: ISightSeenViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.visitId = data["visitId"];
            this.dateSeen = data["dateSeen"] ? moment(data["dateSeen"].toString()) : <any>undefined;
            this.sightSeenId = data["sightSeenId"];
            this.sightId = data["sightId"];
        }
    }

    static fromJS(data: any): SightSeenViewModel {
        data = typeof data === 'object' ? data : {};
        let result = new SightSeenViewModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["visitId"] = this.visitId;
        data["dateSeen"] = this.dateSeen ? this.dateSeen.toISOString() : <any>undefined;
        data["sightSeenId"] = this.sightSeenId;
        data["sightId"] = this.sightId;
        return data; 
    }
}

export interface ISightSeenViewModel {
    visitId?: string | undefined;
    dateSeen?: moment.Moment | undefined;
    sightSeenId?: number | undefined;
    sightId?: number | undefined;
}

export class UserViewModel implements IUserViewModel {
    userId?: number | undefined;
    username?: string | undefined;
    email?: string | undefined;
    firstName?: string | undefined;
    lastName?: string | undefined;
    profileType?: UserViewModelProfileType | undefined;
    dateOfBirth?: moment.Moment | undefined;

    constructor(data?: IUserViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.userId = data["userId"];
            this.username = data["username"];
            this.email = data["email"];
            this.firstName = data["firstName"];
            this.lastName = data["lastName"];
            this.profileType = data["profileType"];
            this.dateOfBirth = data["dateOfBirth"] ? moment(data["dateOfBirth"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): UserViewModel {
        data = typeof data === 'object' ? data : {};
        let result = new UserViewModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["username"] = this.username;
        data["email"] = this.email;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["profileType"] = this.profileType;
        data["dateOfBirth"] = this.dateOfBirth ? this.dateOfBirth.toISOString() : <any>undefined;
        return data; 
    }
}

export interface IUserViewModel {
    userId?: number | undefined;
    username?: string | undefined;
    email?: string | undefined;
    firstName?: string | undefined;
    lastName?: string | undefined;
    profileType?: UserViewModelProfileType | undefined;
    dateOfBirth?: moment.Moment | undefined;
}

export class TourStatisticsViewModel implements ITourStatisticsViewModel {
    visitsNumber?: number | undefined;
    usersVisited?: number | undefined;
    visitsLastWeek?: number | undefined;
    averageTourTime?: number | undefined;
    commentsNumber?: number | undefined;
    averageMark?: number | undefined;

    constructor(data?: ITourStatisticsViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.visitsNumber = data["visitsNumber"];
            this.usersVisited = data["usersVisited"];
            this.visitsLastWeek = data["visitsLastWeek"];
            this.averageTourTime = data["averageTourTime"];
            this.commentsNumber = data["commentsNumber"];
            this.averageMark = data["averageMark"];
        }
    }

    static fromJS(data: any): TourStatisticsViewModel {
        data = typeof data === 'object' ? data : {};
        let result = new TourStatisticsViewModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["visitsNumber"] = this.visitsNumber;
        data["usersVisited"] = this.usersVisited;
        data["visitsLastWeek"] = this.visitsLastWeek;
        data["averageTourTime"] = this.averageTourTime;
        data["commentsNumber"] = this.commentsNumber;
        data["averageMark"] = this.averageMark;
        return data; 
    }
}

export interface ITourStatisticsViewModel {
    visitsNumber?: number | undefined;
    usersVisited?: number | undefined;
    visitsLastWeek?: number | undefined;
    averageTourTime?: number | undefined;
    commentsNumber?: number | undefined;
    averageMark?: number | undefined;
}

export class UserStatisticsViewModel implements IUserStatisticsViewModel {
    toursVisited?: number | undefined;
    sightsSeen?: number | undefined;
    visits?: VisitInfoViewModel[] | undefined;

    constructor(data?: IUserStatisticsViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.toursVisited = data["toursVisited"];
            this.sightsSeen = data["sightsSeen"];
            if (data["visits"] && data["visits"].constructor === Array) {
                this.visits = [] as any;
                for (let item of data["visits"])
                    this.visits!.push(VisitInfoViewModel.fromJS(item));
            }
        }
    }

    static fromJS(data: any): UserStatisticsViewModel {
        data = typeof data === 'object' ? data : {};
        let result = new UserStatisticsViewModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["toursVisited"] = this.toursVisited;
        data["sightsSeen"] = this.sightsSeen;
        if (this.visits && this.visits.constructor === Array) {
            data["visits"] = [];
            for (let item of this.visits)
                data["visits"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IUserStatisticsViewModel {
    toursVisited?: number | undefined;
    sightsSeen?: number | undefined;
    visits?: VisitInfoViewModel[] | undefined;
}

export class VisitInfoViewModel implements IVisitInfoViewModel {
    visitId?: string | undefined;
    city?: string | undefined;
    country?: string | undefined;
    region?: string | undefined;
    tourTitle?: string | undefined;
    tourId?: number | undefined;
    durationInSeconds?: number | undefined;

    constructor(data?: IVisitInfoViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.visitId = data["visitId"];
            this.city = data["city"];
            this.country = data["country"];
            this.region = data["region"];
            this.tourTitle = data["tourTitle"];
            this.tourId = data["tourId"];
            this.durationInSeconds = data["durationInSeconds"];
        }
    }

    static fromJS(data: any): VisitInfoViewModel {
        data = typeof data === 'object' ? data : {};
        let result = new VisitInfoViewModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["visitId"] = this.visitId;
        data["city"] = this.city;
        data["country"] = this.country;
        data["region"] = this.region;
        data["tourTitle"] = this.tourTitle;
        data["tourId"] = this.tourId;
        data["durationInSeconds"] = this.durationInSeconds;
        return data; 
    }
}

export interface IVisitInfoViewModel {
    visitId?: string | undefined;
    city?: string | undefined;
    country?: string | undefined;
    region?: string | undefined;
    tourTitle?: string | undefined;
    tourId?: number | undefined;
    durationInSeconds?: number | undefined;
}

export class LoginViewModel implements ILoginViewModel {
    login?: string | undefined;
    password?: string | undefined;
    remember?: boolean | undefined;

    constructor(data?: ILoginViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.login = data["login"];
            this.password = data["password"];
            this.remember = data["remember"];
        }
    }

    static fromJS(data: any): LoginViewModel {
        data = typeof data === 'object' ? data : {};
        let result = new LoginViewModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["login"] = this.login;
        data["password"] = this.password;
        data["remember"] = this.remember;
        return data; 
    }
}

export interface ILoginViewModel {
    login?: string | undefined;
    password?: string | undefined;
    remember?: boolean | undefined;
}

export class RegisterViewModel implements IRegisterViewModel {
    password?: string | undefined;
    userId?: number | undefined;
    username?: string | undefined;
    email?: string | undefined;
    firstName?: string | undefined;
    lastName?: string | undefined;
    profileType?: RegisterViewModelProfileType | undefined;
    dateOfBirth?: moment.Moment | undefined;

    constructor(data?: IRegisterViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.password = data["password"];
            this.userId = data["userId"];
            this.username = data["username"];
            this.email = data["email"];
            this.firstName = data["firstName"];
            this.lastName = data["lastName"];
            this.profileType = data["profileType"];
            this.dateOfBirth = data["dateOfBirth"] ? moment(data["dateOfBirth"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): RegisterViewModel {
        data = typeof data === 'object' ? data : {};
        let result = new RegisterViewModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["password"] = this.password;
        data["userId"] = this.userId;
        data["username"] = this.username;
        data["email"] = this.email;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["profileType"] = this.profileType;
        data["dateOfBirth"] = this.dateOfBirth ? this.dateOfBirth.toISOString() : <any>undefined;
        return data; 
    }
}

export interface IRegisterViewModel {
    password?: string | undefined;
    userId?: number | undefined;
    username?: string | undefined;
    email?: string | undefined;
    firstName?: string | undefined;
    lastName?: string | undefined;
    profileType?: RegisterViewModelProfileType | undefined;
    dateOfBirth?: moment.Moment | undefined;
}

export class ResetPasswordViewModel implements IResetPasswordViewModel {
    token?: string | undefined;
    password?: string | undefined;

    constructor(data?: IResetPasswordViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.token = data["token"];
            this.password = data["password"];
        }
    }

    static fromJS(data: any): ResetPasswordViewModel {
        data = typeof data === 'object' ? data : {};
        let result = new ResetPasswordViewModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["token"] = this.token;
        data["password"] = this.password;
        return data; 
    }
}

export interface IResetPasswordViewModel {
    token?: string | undefined;
    password?: string | undefined;
}

export class ChangePasswordViewModel implements IChangePasswordViewModel {
    oldPassword?: string | undefined;
    newPassword?: string | undefined;

    constructor(data?: IChangePasswordViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.oldPassword = data["oldPassword"];
            this.newPassword = data["newPassword"];
        }
    }

    static fromJS(data: any): ChangePasswordViewModel {
        data = typeof data === 'object' ? data : {};
        let result = new ChangePasswordViewModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["oldPassword"] = this.oldPassword;
        data["newPassword"] = this.newPassword;
        return data; 
    }
}

export interface IChangePasswordViewModel {
    oldPassword?: string | undefined;
    newPassword?: string | undefined;
}

export enum UserViewModelProfileType {
    _1 = 1, 
    _2 = 2, 
    _3 = 3, 
}

export enum RegisterViewModelProfileType {
    _1 = 1, 
    _2 = 2, 
    _3 = 3, 
}

export interface FileParameter {
    data: any;
    fileName: string;
}

export class SwaggerException extends Error {
    message: string;
    status: number; 
    response: string; 
    headers: { [key: string]: any; };
    result: any; 

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isSwaggerException = true;

    static isSwaggerException(obj: any): obj is SwaggerException {
        return obj.isSwaggerException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): Observable<any> {
    if(result !== null && result !== undefined)
        return _observableThrow(result);
    else
        return _observableThrow(new SwaggerException(message, status, response, headers, null));
}

function blobToText(blob: any): Observable<string> {
    return new Observable<string>((observer: any) => {
        if (!blob) {
            observer.next("");
            observer.complete();
        } else {
            let reader = new FileReader(); 
            reader.onload = event => { 
                observer.next((<any>event.target).result);
                observer.complete();
            };
            reader.readAsText(blob); 
        }
    });
}